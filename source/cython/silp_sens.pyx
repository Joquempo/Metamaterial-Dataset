"""
Dataset Generation
Topology Optimization of the Base Cell of a Periodic Metamaterial
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2023
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Metamaterial-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2023 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

# cython: boundscheck=False
# cython: wraparound=False
# cython: cdivision=True

cimport cython

cdef void cython_cgs(double [:] dC00_0, double [:] dC11_0, double [:] dC22_0, double [:] dC00_1, double [:] dC11_1,
                     double [:] dC22_1, double [:] dC00_2, double [:] dC11_2, double [:] dC22_2, long long [:] x, long long N,
                     long long [:,::1] sym, long long [:] etype, long long [:] aug_etype, long long [:,::1] inci, double [:,::1] Ug,
                     double [:,:,::1] dKe, long long [:] Pindices, long long [:] Pindptr, long long [:] Kindices,
                     long long [:] Kindptr, double [:] Kdata, double [:,::1] aug_dKe0, double [:,::1] aug_dKe1,
                     double [:,::1] aug_dKe2, double [:,::1] aug_dKe3, double [:,::1] aug_dKe4, double [:,::1] aug_dKe5):
    cdef long long e
    cdef long long i
    cdef long long j
    cdef long long k
    cdef long long kk
    cdef long long kkk
    cdef long long et
    cdef long long ek
    cdef long long aug_ek
    cdef long long n0
    cdef long long n1
    cdef long long n2
    cdef long long n3
    cdef long long dof
    cdef long long ptr0
    cdef long long ptr1
    cdef long long pt0
    cdef long long pt1
    cdef long long ptm
    cdef long long bvar
    cdef long long row
    cdef long long col
    cdef long long dsize
    cdef long long nPids
    cdef long long size_h
    cdef long long nKids
    cdef long long size_k
    cdef long long verylarge
    cdef long long aug_eledofs[48]
    cdef long long Peindptr[49]
    cdef long long Peindices[48]
    cdef long long Pe_h[48]
    cdef long long dofs_h[48]
    cdef long long uniquebool[864]
    cdef long long Kreindices[864]
    cdef long long dofs_k[192]
    cdef long long dofs_kk[192]
    cdef long long elebool[6][8]
    cdef long long eledofs[6][8]
    cdef double dCdx[3]
    cdef double divisor[3]
    cdef double pm1[3]
    cdef double pm2[3]
    cdef double peta2[3]
    cdef double whm[3]
    cdef double wmk[3]
    cdef double wketa[3]
    cdef double wetaxi[3]
    cdef double Minv[192]
    cdef double Kbb[192][192]
    cdef double auxmat[48][48]
    cdef double Ue[48][3]
    cdef double zh[48][3]
    cdef double zm[48][3]
    cdef double zk[192][3]
    cdef double zeta[192][3]
    cdef double zxi[192][3]
    
    verylarge = 9223372036854775807
    for e in range(N):
        for k in range(3):
            dCdx[k] = 0.0
        for k in range(6):
            et = sym[e][k]
            ek = etype[et]
            n0 = inci[et][0]
            n1 = inci[et][1]
            n2 = inci[et][2]
            n3 = inci[et][3]
            eledofs[k][0] = 2*n0
            eledofs[k][1] = 2*n0+1
            eledofs[k][2] = 2*n1
            eledofs[k][3] = 2*n1+1
            eledofs[k][4] = 2*n2
            eledofs[k][5] = 2*n2+1
            eledofs[k][6] = 2*n3
            eledofs[k][7] = 2*n3+1
            for kk in range(8):
                Ue[kk][0] = Ug[eledofs[k][kk]][0]
                Ue[kk][1] = Ug[eledofs[k][kk]][1]
                Ue[kk][2] = Ug[eledofs[k][kk]][2]
            for i in range(8):
                for j in range(8):
                    dCdx[0] = dCdx[0] + Ue[i][0]*dKe[ek][i][j]*Ue[j][0]
                    dCdx[1] = dCdx[1] + Ue[i][1]*dKe[ek][i][j]*Ue[j][1]
                    dCdx[2] = dCdx[2] + Ue[i][2]*dKe[ek][i][j]*Ue[j][2]
        if x[e] == 1:
            dC00_0[e] = -dCdx[0]
            dC11_0[e] = -dCdx[1]
            dC22_0[e] = -dCdx[2]
        else:
            dC00_0[e] = dCdx[0]
            dC11_0[e] = dCdx[1]
            dC22_0[e] = dCdx[2]
        aug_ek = aug_etype[e]
        if aug_ek < 3:
            dsize = 48
        elif aug_ek < 5:
            dsize = 36
        else:
            dsize = 26
        for k in range(6):
            for kk in range(8):
                elebool[k][kk] = 1
        kkk = 0
        for k in range(6):
            for kk in range(8):
                if elebool[k][kk] == 1:
                    for i in range(6):
                        for j in range(8):
                            if eledofs[i][j] == eledofs[k][kk]:
                                elebool[i][j] = 0
                    aug_eledofs[kkk] = eledofs[k][kk]
                    kkk = kkk + 1
        nPids = 0
        Peindptr[0] = 0
        for k in range(dsize):
            Ue[k][0] = Ug[aug_eledofs[k]][0]
            Ue[k][1] = Ug[aug_eledofs[k]][1]
            Ue[k][2] = Ug[aug_eledofs[k]][2]
            ptr0 = Pindptr[aug_eledofs[k]]
            ptr1 = Pindptr[aug_eledofs[k]+1]
            if ptr1 > ptr0:
                Peindptr[k+1] = Peindptr[k] + 1
                Peindices[nPids] = Pindices[ptr0] 
                nPids = nPids + 1
            else:
                Peindptr[k+1] = Peindptr[k]
        for k in range(nPids):
            uniquebool[k] = 1
        size_h = 0
        for k in range(nPids):
            if uniquebool[k] == 1:
                for kk in range(nPids):
                    if Peindices[kk] == Peindices[k]:
                        uniquebool[kk] = 0
                dofs_h[size_h] = Peindices[k]                
                size_h = size_h + 1
        nKids = 0
        for k in range(size_h):
            ptr0 = Kindptr[dofs_h[k]]
            ptr1 = Kindptr[dofs_h[k]+1]
            for kk in range(ptr1-ptr0):
                Kreindices[nKids+kk] = Kindices[ptr0+kk]
            nKids = nKids + (ptr1-ptr0)
        for k in range(nKids):
           uniquebool[k] = 1
        size_k = 0
        for k in range(nKids):
            if uniquebool[k] == 1:
                for kk in range(k,nKids):
                    if Kreindices[kk] == Kreindices[k]:
                        uniquebool[kk] = 0
                dofs_k[size_k] = Kreindices[k]                
                size_k = size_k + 1
        for k in range(size_h):
            dofs_kk[k] = dofs_h[k]
        kkk = size_h
        for k in range(size_k):
            bvar = 1
            for kk in range(size_h):
                if dofs_k[k] == dofs_h[kk]:
                    bvar = 0
                    break
            if bvar == 1:
                dofs_kk[kkk] = dofs_k[k]
                kkk = kkk + 1
        for k in range(dsize):
            Pe_h[k] = verylarge
        row = 0
        for k in range(size_h):
            for kk in range(nPids):
                if Peindices[kk] == dofs_h[k]:
                    for kkk in range(dsize):
                        if kk < Peindptr[kkk+1]:
                            row = kkk
                            break
                    Pe_h[row] = k
        for i in range(size_h):
            for k in range(dsize):
                auxmat[i][k] = 0.0
        if aug_ek == 0:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe0[j][k]
        elif aug_ek == 1:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe1[j][k]
        elif aug_ek == 2:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe2[j][k]
        elif aug_ek==3:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe3[j][k]
        elif aug_ek==4:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe4[j][k]
        else:
            for j in range(dsize):
                i = Pe_h[j]
                if i != verylarge:
                    for k in range(dsize):
                        auxmat[i][k] = auxmat[i][k] + aug_dKe5[j][k]
        for i in range(size_h):
            zh[i][0] = 0.0
            zh[i][1] = 0.0
            zh[i][2] = 0.0
            for j in range(dsize):
                zh[i][0] = zh[i][0] + auxmat[i][j] * Ue[j][0]
                zh[i][1] = zh[i][1] + auxmat[i][j] * Ue[j][1]
                zh[i][2] = zh[i][2] + auxmat[i][j] * Ue[j][2]
        for col in range(size_k):
            ptr0 = Kindptr[dofs_kk[col]]
            ptr1 = Kindptr[dofs_kk[col]+1]
            for row in range(col,size_k):
                dof = dofs_kk[row]
                if (dof < Kindices[ptr0]) or (dof > Kindices[ptr1-1]):
                    Kbb[row][col] = 0.0
                else:
                    pt0 = ptr0
                    pt1 = ptr1
                    bvar = 1
                    while (pt1-pt0) > 1:
                        ptm = (pt0+pt1)//2
                        if dof > Kindices[ptm]:
                            pt0 = ptm
                        elif dof < Kindices[ptm]:
                            pt1 = ptm
                        else:
                            Kbb[row][col] = Kdata[ptm]
                            bvar = 0
                            break
                    if bvar == 1:
                        if dof == Kindices[pt0]:
                            Kbb[row][col] = Kdata[pt0]
                        else:
                            Kbb[row][col] = 0.0
        if x[e] == 1:
            for j in range(dsize):
                k = Pe_h[j]
                for i in range(size_h):
                    if k <= i:
                        Kbb[i][k] = Kbb[i][k] - auxmat[i][j]
        else:
            for j in range(dsize):
                k = Pe_h[j]
                for i in range(size_h):
                    if k <= i:
                        Kbb[i][k] = Kbb[i][k] + auxmat[i][j]
        for k in range(size_k):
            Minv[k] = 1.0/Kbb[k][k]
        for k in range(size_h):            
            zm[k][0] = Minv[k] * zh[k][0]
            zm[k][1] = Minv[k] * zh[k][1]
            zm[k][2] = Minv[k] * zh[k][2]
            zk[k][0] = Kbb[k][k] * zm[k][0]
            zk[k][1] = Kbb[k][k] * zm[k][1]
            zk[k][2] = Kbb[k][k] * zm[k][2]
        for i in range(size_h,size_k):
            zk[i][0] = 0.0
            zk[i][1] = 0.0
            zk[i][2] = 0.0
        for i in range(size_h):
            for j in range(i):
                zk[i][0] = zk[i][0] + Kbb[i][j] * zm[j][0]
                zk[i][1] = zk[i][1] + Kbb[i][j] * zm[j][1]
                zk[i][2] = zk[i][2] + Kbb[i][j] * zm[j][2]
                zk[j][0] = zk[j][0] + Kbb[i][j] * zm[i][0]
                zk[j][1] = zk[j][1] + Kbb[i][j] * zm[i][1]
                zk[j][2] = zk[j][2] + Kbb[i][j] * zm[i][2]
        for i in range(size_h,size_k):
            for j in range(size_h):
                zk[i][0] = zk[i][0] + Kbb[i][j] * zm[j][0]
                zk[i][1] = zk[i][1] + Kbb[i][j] * zm[j][1]
                zk[i][2] = zk[i][2] + Kbb[i][j] * zm[j][2]
        for i in range(size_k):        
            zeta[i][0] = Minv[i] * zk[i][0]
            zeta[i][1] = Minv[i] * zk[i][1]
            zeta[i][2] = Minv[i] * zk[i][2]
            zxi[i][0] = Kbb[i][i] * zeta[i][0]
            zxi[i][1] = Kbb[i][i] * zeta[i][1]
            zxi[i][2] = Kbb[i][i] * zeta[i][2]
        for i in range(size_k):
            for j in range(i):
                zxi[i][0] = zxi[i][0] + Kbb[i][j] * zeta[j][0]
                zxi[i][1] = zxi[i][1] + Kbb[i][j] * zeta[j][1]
                zxi[i][2] = zxi[i][2] + Kbb[i][j] * zeta[j][2]
                zxi[j][0] = zxi[j][0] + Kbb[i][j] * zeta[i][0]
                zxi[j][1] = zxi[j][1] + Kbb[i][j] * zeta[i][1]
                zxi[j][2] = zxi[j][2] + Kbb[i][j] * zeta[i][2]
        whm[0] = 0.0
        whm[1] = 0.0
        whm[2] = 0.0
        wmk[0] = 0.0
        wmk[1] = 0.0
        wmk[2] = 0.0
        for k in range(size_h):
            whm[0] = whm[0] + zh[k][0]*zm[k][0]
            whm[1] = whm[1] + zh[k][1]*zm[k][1]
            whm[2] = whm[2] + zh[k][2]*zm[k][2]
            wmk[0] = wmk[0] + zm[k][0]*zk[k][0]
            wmk[1] = wmk[1] + zm[k][1]*zk[k][1]
            wmk[2] = wmk[2] + zm[k][2]*zk[k][2]
        pm1[0] = whm[0]/wmk[0]
        pm1[1] = whm[1]/wmk[1]
        pm1[2] = whm[2]/wmk[2]
        if x[e] == 1:
            dC00_1[e] = -dCdx[0] - pm1[0]*whm[0]
            dC11_1[e] = -dCdx[1] - pm1[1]*whm[1]
            dC22_1[e] = -dCdx[2] - pm1[2]*whm[2]
        else:
            dC00_1[e] = dCdx[0] - pm1[0]*whm[0]
            dC11_1[e] = dCdx[1] - pm1[1]*whm[1]
            dC22_1[e] = dCdx[2] - pm1[2]*whm[2]
        wketa[0] = 0.0
        wketa[1] = 0.0
        wketa[2] = 0.0
        wetaxi[0] = 0.0
        wetaxi[1] = 0.0
        wetaxi[2] = 0.0
        for k in range(size_k):
            wketa[0] = wketa[0] + zk[k][0]*zeta[k][0]
            wketa[1] = wketa[1] + zk[k][1]*zeta[k][1]
            wketa[2] = wketa[2] + zk[k][2]*zeta[k][2]
            wetaxi[0] = wetaxi[0] + zeta[k][0]*zxi[k][0]
            wetaxi[1] = wetaxi[1] + zeta[k][1]*zxi[k][1]
            wetaxi[2] = wetaxi[2] + zeta[k][2]*zxi[k][2]
        divisor[0] = wmk[0]*wetaxi[0]-wketa[0]*wketa[0]
        divisor[1] = wmk[1]*wetaxi[1]-wketa[1]*wketa[1]
        divisor[2] = wmk[2]*wetaxi[2]-wketa[2]*wketa[2]
        pm2[0] = (whm[0]*wetaxi[0]-wmk[0]*wketa[0])/divisor[0]
        pm2[1] = (whm[1]*wetaxi[1]-wmk[1]*wketa[1])/divisor[1]
        pm2[2] = (whm[2]*wetaxi[2]-wmk[2]*wketa[2])/divisor[2]
        peta2[0] = (wmk[0]*wmk[0]-whm[0]*wketa[0])/divisor[0]
        peta2[1] = (wmk[1]*wmk[1]-whm[1]*wketa[1])/divisor[1]
        peta2[2] = (wmk[2]*wmk[2]-whm[2]*wketa[2])/divisor[2]
        if x[e] == 1:
            dC00_2[e] = -dCdx[0] - (pm2[0]*whm[0]+peta2[0]*wmk[0])
            dC11_2[e] = -dCdx[1] - (pm2[1]*whm[1]+peta2[1]*wmk[1])
            dC22_2[e] = -dCdx[2] - (pm2[2]*whm[2]+peta2[2]*wmk[2])
        else:
            dC00_2[e] =  dCdx[0] - (pm2[0]*whm[0]+peta2[0]*wmk[0])
            dC11_2[e] =  dCdx[1] - (pm2[1]*whm[1]+peta2[1]*wmk[1])
            dC22_2[e] =  dCdx[2] - (pm2[2]*whm[2]+peta2[2]*wmk[2])
    return

def cgs(dC00_0,dC11_0,dC22_0,dC00_1,dC11_1,dC22_1,dC00_2,dC11_2,dC22_2,x,N,sym,etype,aug_etype,inci,Ug,dKe,P,Kr,dKelist):
    cython_cgs(dC00_0, dC11_0, dC22_0, dC00_1, dC11_1, dC22_1, dC00_2, dC11_2, dC22_2, x.astype("int64"),
               N, sym.astype("int64"), etype.astype("int64"), aug_etype.astype("int64"),inci.astype("int64"), Ug, dKe,
               P.indices.astype("int64"), P.indptr.astype("int64"), Kr.indices.astype("int64"), Kr.indptr.astype("int64"), Kr.data,
               dKelist[0], dKelist[1], dKelist[2], dKelist[3], dKelist[4], dKelist[5])
    return