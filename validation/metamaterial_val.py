"""
Dataset Generation
Topology Optimization of the Base Cell of a Periodic Metamaterial
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2023
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Metamaterial-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2023 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

#%% Imports
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.collections as clct
from scipy.sparse import coo_matrix
from sksparse.cholmod import analyze

sys.path.append('./cython/')
from cgm import cgm_solve

sys.path.append('../source/python/SILP/')
from elem import get_emat, get_augmat, getB
from mesh import get_mesh, get_fmesh
from filters import get_sfil, get_mope
from rem_islands import visit, get_neighbors
from topopt import update, ws

sys.path.append('../source/cython/')
from silp_sens import cgs

#%% Setup

# fixed properties
Ns = 32        # number of elements in each side of the design domain
rsen  = 0.024  # sensitivity filter radius
rmor  = 0.018  # morphology filter radius
Ey = 1.00      # Young's modulus of the base material
nu = 0.30      # Poisson's ratio of the base material
nuval = -1.0   # target Poisson's ratio
pk = 1e-9      # soft-kill parameter
small = 1e-12  # small value to compare float numbers

# area = 6*Lx*Ly = 1.0
Lx = 1.0/(108**0.25)  # design domain shorter side
Ly = np.sqrt(3)*Lx    # design domain longer side
Lex = Lx/Ns           # element shorter side
Ley = np.sqrt(3)*Lex  # element longer side
N = Ns**2             # number of elements in the design domain
Nt = 6*N              # number of elements in the base cell
M = 1 + 6*Ns*(Ns+1)   # number of nodes in the base cell
G = 2*M               # number of degrees of freedom in the base cell

# generate mesh
coor, inci, etype, sym = get_mesh(Ns, Lex, Ley)

# element matrices (Quad4) - plane stress state
Ket = get_emat(Ey,nu)
Ketvec = np.ndarray((12,64))
dKe = np.ndarray((12,8,8))
for ek in range(12):
    Ketvec[ek,:] = Ket[ek,:,:].ravel()
    dKe[ek,:,:] = (1.0-pk)*Ket[ek,:,:]  # stiffness variation of a topological change
# augmented element matrices (6xQuad4)
aug_etype, Hlist, dKelist = get_augmat(Ns,inci,etype,sym,dKe)

# generate extended mesh
coor_lb, coor_bot, inci_lb, inci_bot, sym_lb, sym_bot = get_fmesh(Ns, Lx, Ly, Lex, Ley)

# sensitivity and morphology filters matrices
fcoor = np.vstack((coor,coor_lb,coor_bot))
finci = np.vstack((inci,inci_lb,inci_bot))
fsym = np.hstack((sym,sym_lb,sym_bot))
elepos = 0.25*fcoor[finci].sum(axis=1)
row = fsym.ravel('C')
col = np.repeat(np.arange(N),10)
data = np.ones(10*N)
Q = coo_matrix((data,(row,col)),shape=(10*N,N))
Q = Q.tocsc()
# sensitivity filter matrix
Sf = get_sfil(N,sym,elepos,Q,rsen)
# morphology filter matrix
Mf = get_mope(N,sym,elepos,Q,rmor)

# get neighbors
neighbors = get_neighbors(Ns,inci,inci_lb,inci_bot,sym,sym_lb,sym_bot)

# periodic boundary conditions
Gb = 4*Ns
Gd = G - 2 - 6*Gb
Gr = Gd + 3*Gb - 2
ivec = np.arange(2,G)
j0 = np.arange(0,Gd)
j1 = np.arange(Gd,Gd+3*Gb-2)
v1=np.arange(Gd+Gb-2,Gd-1,-2)
v2=np.arange(Gd+Gb-1,Gd,-2)
j2=np.vstack((v1,v2)).ravel('F')
v1=np.arange(Gd+2*Gb-2,Gd+Gb-3,-2)
v2=np.arange(Gd+2*Gb-1,Gd+Gb-2,-2)
j3=np.vstack((v1,v2)).ravel('F')
v1=np.arange(Gd+3*Gb-4,Gd+2*Gb-3,-2)
v2=np.arange(Gd+3*Gb-3,Gd+2*Gb-2,-2)
j4=np.vstack((v1,v2)).ravel('F')
jvec = np.concatenate((j0,j1,j2,j3,j4))
avec = np.ones(G-2)
P = coo_matrix((avec,(ivec,jvec)),shape=(G,Gr)).tocsr()
# macro-strain tensors
eps_xx = np.array([[1,0],[0,0]])
eps_yy = np.array([[0,0],[0,1]])
eps_xy = np.array([[0,0.5],[0.5,0]])
# macro-displacements vectors
uhat_xx = np.ravel(coor @ eps_xx, 'C')
uhat_yy = np.ravel(coor @ eps_yy, 'C')
uhat_xy = np.ravel(coor @ eps_xy, 'C')
Uhat = np.vstack((uhat_xx,uhat_yy,uhat_xy)).T

# topologies
x1 = np.ones(N,dtype=bool)
x2 = np.zeros(N,dtype=bool)
x3 = x1.copy()
Ntotal = Ns//16
Nhole = Ntotal
while Nhole > 0:
    x3[(Ns-1-(Ntotal-Nhole))*Ns+(Ns//2-Nhole):(Ns-1-(Ntotal-Nhole))*Ns+(Ns//2+Nhole)] = False
    Nhole = Nhole - 1
x4 = (np.random.rand(N) > 0.5)
xt1 = np.ndarray((Nt),dtype=bool)
xt2 = np.ndarray((Nt),dtype=bool)
xt3 = np.ndarray((Nt),dtype=bool)
xt4 = np.ndarray((Nt),dtype=bool)
for k in range(N):
    xt1[sym[k,:]] = x1[k]
    xt2[sym[k,:]] = x2[k]
    xt3[sym[k,:]] = x3[k]
    xt4[sym[k,:]] = x4[k]

#%% Homogenization Procedure
print('[Homogenization Procedure]')

# Assembly
# COO data
pen1 = np.ones(Nt)
pen2 = np.ones(Nt)
pen3 = np.ones(Nt)
pen4 = np.ones(Nt)
pen1[~xt1] = pk
pen2[~xt2] = pk
pen3[~xt3] = pk
pen4[~xt4] = pk
data1 = np.ndarray((64*Nt))
data2 = np.ndarray((64*Nt))
data3 = np.ndarray((64*Nt))
data4 = np.ndarray((64*Nt))
for et in range(Nt):
    ek = etype[et]
    data1[64*et:64*et+64] = pen1[et]*Ketvec[ek,:]
    data2[64*et:64*et+64] = pen2[et]*Ketvec[ek,:]
    data3[64*et:64*et+64] = pen3[et]*Ketvec[ek,:]
    data4[64*et:64*et+64] = pen4[et]*Ketvec[ek,:]
# COO indices
dof0 = 2*inci[:,0]
dof1 = dof0 + 1
dof2 = 2*inci[:,1]
dof3 = dof2 + 1
dof4 = 2*inci[:,2]
dof5 = dof4 + 1
dof6 = 2*inci[:,3]
dof7 = dof6 + 1
eledofs = np.array([dof0,dof1,dof2,dof3,dof4,dof5,dof6,dof7])
row = eledofs.repeat(8,axis=0).ravel('F')
col = eledofs.T.repeat(8,axis=0).ravel('C')
# stiffness matrix
Kg_coo1 = coo_matrix((data1,(row,col)),shape=(G,G))
Kg_coo2 = coo_matrix((data2,(row,col)),shape=(G,G))
Kg_coo3 = coo_matrix((data3,(row,col)),shape=(G,G))
Kg_coo4 = coo_matrix((data4,(row,col)),shape=(G,G))
Kg_csc1 = Kg_coo1.tocsc()
Kg_csc2 = Kg_coo2.tocsc()
Kg_csc3 = Kg_coo3.tocsc()
Kg_csc4 = Kg_coo4.tocsc()
Kr1 = P.T @ Kg_csc1 @ P
Kr2 = P.T @ Kg_csc2 @ P
Kr3 = P.T @ Kg_csc3 @ P
Kr4 = P.T @ Kg_csc4 @ P
# maneuver to fix the pattern of non-zero entries
Z_coo = coo_matrix((np.ones(64*Nt),(row,col)),shape=(G,G))
Z_csc = Z_coo.tocsc()
Zr = P.T @ Z_csc @ P
Zr.sort_indices()
shift = 10*np.amax(abs(Ket))
Kr1 = Kr1 + shift*Zr
Kr2 = Kr2 + shift*Zr
Kr3 = Kr3 + shift*Zr
Kr4 = Kr4 + shift*Zr
Kr1.sort_indices()
Kr2.sort_indices()
Kr3.sort_indices()
Kr4.sort_indices()
Kr1.data = Kr1.data - shift*Zr.data
Kr2.data = Kr2.data - shift*Zr.data
Kr3.data = Kr3.data - shift*Zr.data
Kr4.data = Kr4.data - shift*Zr.data
# right-hand side
Fr1 = -P.T @ Kg_csc1 @ Uhat
Fr2 = -P.T @ Kg_csc2 @ Uhat
Fr3 = -P.T @ Kg_csc3 @ Uhat
Fr4 = -P.T @ Kg_csc4 @ Uhat

# Solve System
# analyze sparse matrix
factor = analyze(Kr1)
# call solver
factor.cholesky_inplace(Kr1)
Ur1 = factor(Fr1)
Ug1 = Uhat + P @ Ur1
factor.cholesky_inplace(Kr2)
Ur2 = factor(Fr2)
Ug2 = Uhat + P @ Ur2
factor.cholesky_inplace(Kr3)
Ur3 = factor(Fr3)
Ug3 = Uhat + P @ Ur3
factor.cholesky_inplace(Kr4)
Ur4 = factor(Fr4)
Ug4 = Uhat + P @ Ur4

# Effective Properties Matrix
Ch1 = Ug1.T @ Kg_csc1 @ Ug1
Ch2 = Ug2.T @ Kg_csc2 @ Ug2
Ch3 = Ug3.T @ Kg_csc3 @ Ug3
Ch4 = Ug4.T @ Kg_csc4 @ Ug4
gamma1 = Ch1[2,2]/Ch1[0,0]
gamma2 = Ch2[2,2]/Ch2[0,0]
gamma3 = Ch3[2,2]/Ch3[0,0]
gamma4 = Ch4[2,2]/Ch4[0,0]
nuhat1 = 1-2*Ch1[2,2]/Ch1[0,0]
nuhat2 = 1-2*Ch2[2,2]/Ch2[0,0]
nuhat3 = 1-2*Ch3[2,2]/Ch3[0,0]
nuhat4 = 1-2*Ch4[2,2]/Ch4[0,0]
Eyhat1 = 4*Ch1[2,2]*(Ch1[0,0]-Ch1[2,2])/Ch1[0,0]
Eyhat2 = 4*Ch2[2,2]*(Ch2[0,0]-Ch2[2,2])/Ch2[0,0]
Eyhat3 = 4*Ch3[2,2]*(Ch3[0,0]-Ch3[2,2])/Ch3[0,0]
Eyhat4 = 4*Ch4[2,2]*(Ch4[0,0]-Ch4[2,2])/Ch4[0,0]

print('> Isotropic metamaterial in plane stress state...')
e1 = abs(Ch1[0,0] - Ch1[1,1])
e2 = abs(Ch1[0,1] - Ch1[1,0])
e3 = abs(Ch1[0,2]) + abs(Ch1[1,2]) + abs(Ch1[2,0]) + abs(Ch1[2,1])
e4 = abs(Ch1[0,0] - Ch1[1,0] - 2.0*Ch1[2,2])
print('> > error_1 = {:.4e} %'.format(100*max([e1,e2,e3,e4])/abs(Ch1).max()))
e1 = abs(Ch2[0,0] - Ch2[1,1])
e2 = abs(Ch2[0,1] - Ch2[1,0])
e3 = abs(Ch2[0,2]) + abs(Ch2[1,2]) + abs(Ch2[2,0]) + abs(Ch2[2,1])
e4 = abs(Ch2[0,0] - Ch2[1,0] - 2.0*Ch2[2,2])
print('> > error_2 = {:.4e} %'.format(100*max([e1,e2,e3,e4])/abs(Ch2).max()))
e1 = abs(Ch3[0,0] - Ch3[1,1])
e2 = abs(Ch3[0,1] - Ch3[1,0])
e3 = abs(Ch3[0,2]) + abs(Ch3[1,2]) + abs(Ch3[2,0]) + abs(Ch3[2,1])
e4 = abs(Ch3[0,0] - Ch3[1,0] - 2.0*Ch3[2,2])
print('> > error_3 = {:.4e} %'.format(100*max([e1,e2,e3,e4])/abs(Ch3).max()))
e1 = abs(Ch4[0,0] - Ch4[1,1])
e2 = abs(Ch4[0,1] - Ch4[1,0])
e3 = abs(Ch4[0,2]) + abs(Ch4[1,2]) + abs(Ch4[2,0]) + abs(Ch4[2,1])
e4 = abs(Ch4[0,0] - Ch4[1,0] - 2.0*Ch4[2,2])
print('> > error_4 = {:.4e} %'.format(100*max([e1,e2,e3,e4])/abs(Ch4).max()))

print('> Anti-symmetric loads over the edges of the base cell...')
plt.figure(num=0).clear()
plt.title('External loads for each case',y=-0.05)
plt.axis('off')
fig,ax = plt.subplots(nrows=4,ncols=3,num=0)
R1 = Kg_csc1 @ Ug1
R2 = Kg_csc2 @ Ug2
R3 = Kg_csc3 @ Ug3
R4 = Kg_csc4 @ Ug4
rmap1 = np.ndarray((Nt,3))
rmap2 = np.ndarray((Nt,3))
rmap3 = np.ndarray((Nt,3))
rmap4 = np.ndarray((Nt,3))
for e in range(Nt):
    nodes = inci[e,:]
    gdl = 2*nodes.repeat(2)
    gdl[1::2] = gdl[1::2] + 1
    for k in range(3):
        rmap1[e,k] = max(abs(R1[gdl,k]))*np.sign(sum(R1[gdl,k][k%2::2]))
        rmap2[e,k] = max(abs(R2[gdl,k]))*np.sign(sum(R2[gdl,k][k%2::2]))
        rmap3[e,k] = max(abs(R3[gdl,k]))*np.sign(sum(R3[gdl,k][k%2::2]))
        rmap4[e,k] = max(abs(R4[gdl,k]))*np.sign(sum(R4[gdl,k][k%2::2]))
for k in range(3):
    polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
    polys.set_array(rmap1[:,k])
    ax[0,k].add_collection(polys)
    ax[0,k].set_aspect('equal')
    ax[0,k].set_xlim([-2*Lx,2*Lx])
    ax[0,k].set_ylim([-Ly,Ly])
    ax[0,k].axis('off')
    ax[0,k].title.set_text('{:.1e} : {:.1e}'.format(min(rmap1[:,k]),max(rmap1[:,k])))
    polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
    polys.set_array(rmap2[:,k])
    ax[1,k].add_collection(polys)
    ax[1,k].set_aspect('equal')
    ax[1,k].set_xlim([-2*Lx,2*Lx])
    ax[1,k].set_ylim([-Ly,Ly])
    ax[1,k].axis('off')
    ax[1,k].title.set_text('{:.1e} : {:.1e}'.format(min(rmap2[:,k]),max(rmap2[:,k])))
    polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
    polys.set_array(rmap3[:,k])
    ax[2,k].add_collection(polys)
    ax[2,k].set_aspect('equal')
    ax[2,k].set_xlim([-2*Lx,2*Lx])
    ax[2,k].set_ylim([-Ly,Ly])
    ax[2,k].axis('off')
    ax[2,k].title.set_text('{:.1e} : {:.1e}'.format(min(rmap3[:,k]),max(rmap3[:,k])))
    polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
    polys.set_array(rmap4[:,k])
    ax[3,k].add_collection(polys)
    ax[3,k].set_aspect('equal')
    ax[3,k].set_xlim([-2*Lx,2*Lx])
    ax[3,k].set_ylim([-Ly,Ly])
    ax[3,k].axis('off')
    ax[3,k].title.set_text('{:.1e} : {:.1e}'.format(min(rmap4[:,k]),max(rmap4[:,k])))
fig.set_size_inches(7,9)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
er = abs(P.T @ R1).max()/abs(R1).max()
print('> > error_1 = {:.4e} %'.format(100*er))
er = abs(P.T @ R2).max()/abs(R2).max()
print('> > error_2 = {:.4e} %'.format(100*er))
er = abs(P.T @ R3).max()/abs(R3).max()
print('> > error_3 = {:.4e} %'.format(100*er))
er = abs(P.T @ R4).max()/abs(R4).max()
print('> > error_4 = {:.4e} %'.format(100*er))

print('> Expected relation between mean strain and mean stress...')
Ce = (Ey/(1-nu**2))*np.array([[1,nu,0],[nu,1,0],[0,0,(1-nu)/2]])
gpoint = np.sqrt(3)/3
mean_eps1 = np.zeros((3,3))
mean_eps2 = np.zeros((3,3))
mean_eps3 = np.zeros((3,3))
mean_eps4 = np.zeros((3,3))
mean_sig1 = np.zeros((3,3))
mean_sig2 = np.zeros((3,3))
mean_sig3 = np.zeros((3,3))
mean_sig4 = np.zeros((3,3))
for e in range(Nt):
    nodes = inci[e,:]
    sv = coor[nodes,:]
    B0, J0 = getB(-gpoint, -gpoint, sv)
    B1, J1 = getB( gpoint, -gpoint, sv)
    B2, J2 = getB( gpoint,  gpoint, sv)
    B3, J3 = getB(-gpoint,  gpoint, sv)
    Be = J0 * B0 + J1 * B1 + J2 * B2 + J3 * B3
    gdl = 2*nodes.repeat(2)
    gdl[1::2] = gdl[1::2] + 1
    Ue1 = Ug1[gdl,:]
    Ue2 = Ug2[gdl,:]
    Ue3 = Ug3[gdl,:]
    Ue4 = Ug4[gdl,:]
    eps1 = Be @ Ue1
    eps2 = Be @ Ue2
    eps3 = Be @ Ue3
    eps4 = Be @ Ue4
    De1 = (pk + (1.0-pk)*xt1[e]) * Ce
    De2 = (pk + (1.0-pk)*xt2[e]) * Ce
    De3 = (pk + (1.0-pk)*xt3[e]) * Ce
    De4 = (pk + (1.0-pk)*xt4[e]) * Ce
    sig1 = De1 @ eps1
    sig2 = De2 @ eps2
    sig3 = De3 @ eps3
    sig4 = De4 @ eps4
    mean_eps1 += eps1
    mean_eps2 += eps2
    mean_eps3 += eps3
    mean_eps4 += eps4
    mean_sig1 += sig1
    mean_sig2 += sig2
    mean_sig3 += sig3
    mean_sig4 += sig4
e1 = abs(mean_eps1-np.identity(3)).max()
e2 = abs(Ch1@mean_eps1-mean_sig1).max()/abs(mean_sig1).max()
print('> > error_1 = {:.4e} %'.format(100*max([e1,e2])))
e1 = abs(mean_eps2-np.identity(3)).max()
e2 = abs(Ch2@mean_eps2-mean_sig2).max()/abs(mean_sig2).max()
print('> > error_2 = {:.4e} %'.format(100*max([e1,e2])))
e1 = abs(mean_eps3-np.identity(3)).max()
e2 = abs(Ch3@mean_eps3-mean_sig3).max()/abs(mean_sig3).max()
print('> > error_3 = {:.4e} %'.format(100*max([e1,e2])))
e1 = abs(mean_eps4-np.identity(3)).max()
e2 = abs(Ch4@mean_eps4-mean_sig4).max()/abs(mean_sig4).max()
print('> > error_4 = {:.4e} %'.format(100*max([e1,e2])))

print('> Check gamma, nuhat and Eyhat...')
print('> > gamma : {:7.4f} | {:7.4f} | {:7.4f} | {:7.4f}'.format(gamma1,gamma2,gamma3,gamma4))
print('> > gamma in  ]0,1[ : {}'.format((gamma1>0.0) and (gamma1<1.0) and (gamma2>0.0) and (gamma2<1.0) and
                                       (gamma3>0.0) and (gamma3<1.0) and (gamma4>0.0) and (gamma4<1.0)))
print('> > nuhat : {:7.4f} | {:7.4f} | {:7.4f} | {:7.4f}'.format(nuhat1,nuhat2,nuhat3,nuhat4))
print('> > nuhat in ]-1,1[ : {}'.format((nuhat1>-1.0) and (nuhat1<1.0) and (nuhat2>-1.0) and (nuhat2<1.0) and
                                        (nuhat3>-1.0) and (nuhat3<1.0) and (nuhat4>-1.0) and (nuhat4<1.0)))
print('> > Eyhat : {:7.4f} | {:7.4f} | {:7.4f} | {:7.4f}'.format(Eyhat1,Eyhat2,Eyhat3,Eyhat4))
print('> > Eyhat in  ]0,1] : {}'.format((Eyhat1>0.0) and (Eyhat1<1.0+small) and (Eyhat2>0.0) and (Eyhat2<1.0+small) and
                                       (Eyhat3>0.0) and (Eyhat3<1.0+small) and (Eyhat4>0.0) and (Eyhat4<1.0+small)))

print('======================================================================')

#%% Topology Update
print('[Topology Update]')

print('> Check vectors and matrices...')
x = x1.copy()
Kg_coo = Kg_coo1.copy()
elist = list(np.argwhere(x1!=x4)[:,0])
Ug, Kr = update(x,etype,sym,pk,Ketvec,P,Kg_coo,Zr,shift,Uhat,factor,elist)
e1 = abs(Ug-Ug4).max()/abs(Ug).max()
e2 = len((Kr-Kr4).data)/len(Kr.data)
print('> > error_1_to_4 : {:.4e} %'.format(100*max([e1,e2])))

print('> Shift maneuver...')
Kg_coo = Kg_coo4.copy()
Kg_csc = Kg_coo.tocsc()
Kr = P.T @ Kg_csc @ P
Kr_shift = Kr + shift*Zr
Kr_shift.sort_indices()
Kr_shift.data = Kr_shift.data - shift*Zr.data
er = abs((Kr-Kr_shift).data).max()/abs(Kr.data).max()
print('> > error_shift  : {:.4e} %'.format(100*er))

print('======================================================================')

#%% Sensitivity Values
print('[Sensitivity Values]')

print('> CGS validation...')
dC00_0 = np.ndarray((N))
dC11_0 = np.ndarray((N))
dC22_0 = np.ndarray((N))
dC00_1 = np.ndarray((N))
dC11_1 = np.ndarray((N))
dC22_1 = np.ndarray((N))
dC00_2 = np.ndarray((N))
dC11_2 = np.ndarray((N))
dC22_2 = np.ndarray((N))
cgs(dC00_0,dC11_0,dC22_0,dC00_1,dC11_1,dC22_1,dC00_2,dC11_2,dC22_2,
    x4,N,sym,etype,aug_etype,inci,Ug4,dKe,P,Kr4,dKelist)
dCh_0 = np.ndarray((N,3,3))
dCh_1 = np.ndarray((N,3,3))
dCh_2 = np.ndarray((N,3,3))
Kg_coo = Kg_coo4.copy()
for e in range(N):
    x4[e] = not x4[e]
    if x4[e]:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = Ketvec[ek,:]
    else:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = pk*Ketvec[ek,:]
    Kg_csc = Kg_coo.tocsc()
    Kr = P.T @ Kg_csc @ P
    Kr = Kr + shift*Zr
    Kr.sort_indices()
    Kr.data = Kr.data - shift*Zr.data
    Fr = -P.T @ Kg_csc @ Uhat
    # CGS-0
    Ur = Ur4.copy()
    Ug = Uhat + P @ Ur
    Ch = Ug.T @ Kg_csc @ Ug
    dCh_0[e,:,:] = Ch - Ch4
    # CGS-1
    Ur = Ur4.copy()
    cgm_solve(Ur[:,0],Kr,Fr[:,0],Gr,steps=1,precond="J")
    cgm_solve(Ur[:,1],Kr,Fr[:,1],Gr,steps=1,precond="J")
    cgm_solve(Ur[:,2],Kr,Fr[:,2],Gr,steps=1,precond="J")
    Ug = Uhat + P @ Ur
    Ch = Ug.T @ Kg_csc @ Ug
    dCh_1[e,:,:] = Ch - Ch4
    # CGS-2
    Ur = Ur4.copy()
    cgm_solve(Ur[:,0],Kr,Fr[:,0],Gr,steps=2,precond="J")
    cgm_solve(Ur[:,1],Kr,Fr[:,1],Gr,steps=2,precond="J")
    cgm_solve(Ur[:,2],Kr,Fr[:,2],Gr,steps=2,precond="J")
    Ug = Uhat + P @ Ur
    Ch = Ug.T @ Kg_csc @ Ug
    dCh_2[e,:,:] = Ch - Ch4
    x4[e] = not x4[e]
    if x4[e]:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = Ketvec[ek,:]
    else:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = pk*Ketvec[ek,:]
e1 = abs(dCh_0[:,0,0]-dC00_0).max()/abs(dC00_0).max()
e2 = abs(dCh_0[:,1,1]-dC11_0).max()/abs(dC11_0).max()
e3 = abs(dCh_0[:,2,2]-dC22_0).max()/abs(dC22_0).max()
print('> > error_CGS-0 : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dCh_1[:,0,0]-dC00_1).max()/abs(dC00_1).max()
e2 = abs(dCh_1[:,1,1]-dC11_1).max()/abs(dC11_1).max()
e3 = abs(dCh_1[:,2,2]-dC22_1).max()/abs(dC22_1).max()
print('> > error_CGS-1 : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dCh_2[:,0,0]-dC00_2).max()/abs(dC00_2).max()
e2 = abs(dCh_2[:,1,1]-dC11_2).max()/abs(dC11_2).max()
e3 = abs(dCh_2[:,2,2]-dC22_2).max()/abs(dC22_2).max()
print('> > error_CGS-2 : {:.4e} %'.format(100*max([e1,e2,e3])))

print('> Check sign and monotonic behavior of delta_Ch...')
dC00_w, dC11_w, dC22_w = ws(x4,aug_etype,sym,P,factor,inci,Ug4,Hlist)
print('> > negative values for solid elements : {}'.format(
     all(dC00_0[x4] < small) and all(dC00_1[x4] < small) and all(dC00_2[x4] < small) and all(dC00_w[x4] < small) and
     all(dC11_0[x4] < small) and all(dC11_1[x4] < small) and all(dC11_2[x4] < small) and all(dC11_w[x4] < small) and
     all(dC22_0[x4] < small) and all(dC22_1[x4] < small) and all(dC22_2[x4] < small) and all(dC22_w[x4] < small)))
print('> > positive values for void elements  : {}'.format(
     all(dC00_0[~x4] > -small) and all(dC00_1[~x4] > -small) and all(dC00_2[~x4] > -small) and all(dC00_w[~x4] > -small) and
     all(dC11_0[~x4] > -small) and all(dC11_1[~x4] > -small) and all(dC11_2[~x4] > -small) and all(dC11_w[~x4] > -small) and
     all(dC22_0[~x4] > -small) and all(dC22_1[~x4] > -small) and all(dC22_2[~x4] > -small) and all(dC22_w[~x4] > -small)))
print('> > monotonic decrease : {}'.format(
     all(dC00_0 > dC00_1-small) and all(dC00_1 > dC00_2-small) and all(dC00_2 > dC00_w-small) and
     all(dC11_0 > dC11_1-small) and all(dC11_1 > dC11_2-small) and all(dC11_2 > dC11_w-small) and
     all(dC22_0 > dC22_1-small) and all(dC22_1 > dC22_2-small) and all(dC22_2 > dC22_w-small)))

print('> WS validation...')
dCh_w = np.ndarray((N,3,3))
dCh_w2 = np.zeros((N,3,3))
Kg_coo = Kg_coo4.copy()
for e in range(N):
    x4[e] = not x4[e]
    if x4[e]:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = Ketvec[ek,:]
    else:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = pk*Ketvec[ek,:]
    Kg_csc = Kg_coo.tocsc()
    Kr = P.T @ Kg_csc @ P
    Kr = Kr + shift*Zr
    Kr.sort_indices()
    Kr.data = Kr.data - shift*Zr.data
    Fr = -P.T @ Kg_csc @ Uhat
    factor.cholesky_inplace(Kr)
    Ur = factor(Fr)
    Ug = Uhat + P @ Ur
    Ch = Ug.T @ Kg_csc @ Ug
    dCh_w[e,:,:] = Ch - Ch4
    for k in range(6):
        et = sym[e,k]
        nodes = inci[et,:]
        gdl = 2*nodes.repeat(2)
        gdl[1::2] = gdl[1::2] + 1
        ek = etype[et]
        if x4[e]:
            dCh_w2[e,:,:] = dCh_w2[e,:,:] + Ug4[gdl,:].T @ dKe[ek,:,:] @ Ug[gdl,:]
        else:
            dCh_w2[e,:,:] = dCh_w2[e,:,:] - Ug4[gdl,:].T @ dKe[ek,:,:] @ Ug[gdl,:]
    x4[e] = not x4[e]
    if x4[e]:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = Ketvec[ek,:]
    else:
        for k in range(6):
            et = sym[e,k]
            ek = etype[et]
            Kg_coo.data[64*et:64*et+64] = pk*Ketvec[ek,:]
e1 = abs(dCh_w[x4,0,0]-dC00_w[x4]).max()/abs(dC00_w[x4]).max()
e2 = abs(dCh_w[x4,1,1]-dC11_w[x4]).max()/abs(dC11_w[x4]).max()
e3 = abs(dCh_w[x4,2,2]-dC22_w[x4]).max()/abs(dC22_w[x4]).max()
print('> > error_WS  (solids) : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dCh_w2[x4,0,0]-dC00_w[x4]).max()/abs(dC00_w[x4]).max()
e2 = abs(dCh_w2[x4,1,1]-dC11_w[x4]).max()/abs(dC11_w[x4]).max()
e3 = abs(dCh_w2[x4,2,2]-dC22_w[x4]).max()/abs(dC22_w[x4]).max()
print('> > error_WS2 (solids) : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dCh_w[~x4,0,0]-dC00_w[~x4]).max()/abs(dC00_w[~x4]).max()
e2 = abs(dCh_w[~x4,1,1]-dC11_w[~x4]).max()/abs(dC11_w[~x4]).max()
e3 = abs(dCh_w[~x4,2,2]-dC22_w[~x4]).max()/abs(dC22_w[~x4]).max()
print('> > error_WS  (voids)  : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dCh_w2[~x4,0,0]-dC00_w[~x4]).max()/abs(dC00_w[~x4]).max()
e2 = abs(dCh_w2[~x4,1,1]-dC11_w[~x4]).max()/abs(dC11_w[~x4]).max()
e3 = abs(dCh_w2[~x4,2,2]-dC22_w[~x4]).max()/abs(dC22_w[~x4]).max()
print('> > error_WS2 (voids)  : {:.4e} %'.format(100*max([e1,e2,e3])))

print('> Sensitivity error...')
nuhat = 1-2*(Ch4[2,2]+dCh_w[:,2,2])/(Ch4[0,0]+dCh_w[:,0,0])
Eyhat = 4*(Ch4[2,2]+dCh_w[:,2,2])*((Ch4[0,0]+dCh_w[:,0,0])-(Ch4[2,2]+dCh_w[:,2,2]))/(Ch4[0,0]+dCh_w[:,0,0])
obj = (nuhat-nuval)**2
obj4 = (nuhat4-nuval)**2
dnu_ref = nuhat - nuhat4
dEy_ref = Eyhat - Eyhat4
dobj_ref = obj - obj4
ggamma_0 = (Ch4[2,2]+dC22_0)/(Ch4[0,0]+dC00_0)
ggamma_1 = (Ch4[2,2]+dC22_1)/(Ch4[0,0]+dC00_1)
ggamma_2 = (Ch4[2,2]+dC22_2)/(Ch4[0,0]+dC00_2)
ggamma_w = (Ch4[2,2]+dC22_w)/(Ch4[0,0]+dC00_w)
dnu_0 = 2.0*(gamma4*dC00_0-dC22_0)/(Ch4[0,0]+dC00_0)
dnu_1 = 2.0*(gamma4*dC00_1-dC22_1)/(Ch4[0,0]+dC00_1)
dnu_2 = 2.0*(gamma4*dC00_2-dC22_2)/(Ch4[0,0]+dC00_2)
dnu_w = 2.0*(gamma4*dC00_w-dC22_w)/(Ch4[0,0]+dC00_w)
dEy_0 = 4.0*(1.0-ggamma_0)*dC22_0 + 2.0*Ch4[2,2]*dnu_0
dEy_1 = 4.0*(1.0-ggamma_1)*dC22_1 + 2.0*Ch4[2,2]*dnu_1
dEy_2 = 4.0*(1.0-ggamma_2)*dC22_2 + 2.0*Ch4[2,2]*dnu_2
dEy_w = 4.0*(1.0-ggamma_w)*dC22_w + 2.0*Ch4[2,2]*dnu_w
dobj_0 = 2.0*(nuhat4-nuval)*dnu_0 + dnu_0*dnu_0
dobj_1 = 2.0*(nuhat4-nuval)*dnu_1 + dnu_1*dnu_1
dobj_2 = 2.0*(nuhat4-nuval)*dnu_2 + dnu_2*dnu_2
dobj_w = 2.0*(nuhat4-nuval)*dnu_w + dnu_w*dnu_w
E00_0 = dC00_w-dC00_0
E00_1 = dC00_w-dC00_1
E00_2 = dC00_w-dC00_2
E22_0 = dC22_w-dC22_0
E22_1 = dC22_w-dC22_1
E22_2 = dC22_w-dC22_2
enu_0 = 2*(ggamma_w*E00_0 - E22_0)/((Ch4[0,0]+dC00_w)-E00_0)
enu_1 = 2*(ggamma_w*E00_1 - E22_1)/((Ch4[0,0]+dC00_w)-E00_1)
enu_2 = 2*(ggamma_w*E00_2 - E22_2)/((Ch4[0,0]+dC00_w)-E00_2)
eEy_0 = ((2*ggamma_w)**2)*E00_0 + 4*(1-2*ggamma_w)*E22_0 + (4*(ggamma_w*E00_0-E22_0)**2)/((Ch4[0,0]+dC00_w)-E00_0)
eEy_1 = ((2*ggamma_w)**2)*E00_1 + 4*(1-2*ggamma_w)*E22_1 + (4*(ggamma_w*E00_1-E22_1)**2)/((Ch4[0,0]+dC00_w)-E00_1)
eEy_2 = ((2*ggamma_w)**2)*E00_2 + 4*(1-2*ggamma_w)*E22_2 + (4*(ggamma_w*E00_2-E22_2)**2)/((Ch4[0,0]+dC00_w)-E00_2)
eobj_0 = 2*(1-2*ggamma_w-nuval)*enu_0 - enu_0**2
eobj_1 = 2*(1-2*ggamma_w-nuval)*enu_1 - enu_1**2
eobj_2 = 2*(1-2*ggamma_w-nuval)*enu_2 - enu_2**2
e1 = abs((dnu_w-dnu_0)-enu_0).max()/abs(enu_0).max()
e2 = abs((dEy_w-dEy_0)-eEy_0).max()/abs(eEy_0).max()
e3 = abs((dobj_w-dobj_0)-eobj_0).max()/abs(eobj_0).max()
print('> > consistency_error_CGS-0 : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs((dnu_w-dnu_1)-enu_1).max()/abs(enu_1).max()
e2 = abs((dEy_w-dEy_1)-eEy_1).max()/abs(eEy_1).max()
e3 = abs((dobj_w-dobj_1)-eobj_1).max()/abs(eobj_1).max()
print('> > consistency_error_CGS-1 : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs((dnu_w-dnu_2)-enu_2).max()/abs(enu_2).max()
e2 = abs((dEy_w-dEy_2)-eEy_2).max()/abs(eEy_2).max()
e3 = abs((dobj_w-dobj_2)-eobj_2).max()/abs(eobj_2).max()
print('> > consistency_error_CGS-2 : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dnu_w[x4]-dnu_ref[x4]).max()/abs(dnu_ref[x4]).max()
e2 = abs(dEy_w[x4]-dEy_ref[x4]).max()/abs(dEy_ref[x4]).max()
e3 = abs(dobj_w[x4]-dobj_ref[x4]).max()/abs(dobj_ref[x4]).max()
print('> > error_WS (solids) : {:.4e} %'.format(100*max([e1,e2,e3])))
e1 = abs(dnu_w[~x4]-dnu_ref[~x4]).max()/abs(dnu_ref[~x4]).max()
e2 = abs(dEy_w[~x4]-dEy_ref[~x4]).max()/abs(dEy_ref[~x4]).max()
e3 = abs(dobj_w[~x4]-dobj_ref[~x4]).max()/abs(dobj_ref[~x4]).max()
print('> > error_WS (voids)  : {:.4e} %'.format(100*max([e1,e2,e3])))
plt.figure(num=1).clear()
fig,ax = plt.subplots(nrows=3,ncols=1,num=1)
ax[0].plot(abs(enu_0))
ax[0].plot(abs(enu_1))
ax[0].plot(abs(enu_2))
ax[0].axis([0,N-1,0,1.01*max([abs(enu_0).max(),abs(enu_1).max(),abs(enu_2).max()])])
ax[0].set_xticks([],[])
ax[0].set_ylabel('Poisson\'s ratio CGS-error')
ax[0].legend(['CGS-0','CGS-1','CGS-2'],loc='upper left')
ax[1].plot(abs(eEy_0))
ax[1].plot(abs(eEy_1))
ax[1].plot(abs(eEy_2))
ax[1].axis([0,N-1,0,1.01*max([abs(eEy_0).max(),abs(eEy_1).max(),abs(eEy_2).max()])])
ax[1].set_xticks([],[])
ax[1].set_ylabel('Young\'s modulus CGS-error')
ax[2].plot(abs(eobj_0))
ax[2].plot(abs(eobj_1))
ax[2].plot(abs(eobj_2))
ax[2].axis([0,N-1,0,1.01*max([abs(eobj_0).max(),abs(eobj_1).max(),abs(eobj_2).max()])])
ax[2].set_ylabel('objective function CGS-error')
ax[2].set_xlabel('element index')
fig.set_size_inches(10,9)

print('======================================================================')

#%% Sensitivity Filter
print('[Sensitivity Filter]')
plt.figure(num=2).clear()
fig,ax = plt.subplots(nrows=3,ncols=2,num=2)
xmin = -2*Lx
xmax =  2*Lx
ymin =   -Ly
ymax =    Ly
# ======================================================================
splot = np.ndarray((Nt))
for e in range(N):
    splot[sym[e,:]] = x4[e]
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
ax[0,0].add_collection(polys)
ax[0,0].set_aspect('equal')
ax[0,0].set_xlim([xmin,xmax])
ax[0,0].set_ylim([ymin,ymax])
ax[0,0].axis('off')
x4fil = Sf@x4
splot = np.ndarray((Nt))
for e in range(N):
    splot[sym[e,:]] = x4fil[e]
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
polys.set_clim(0.0,1.0)
ax[1,0].add_collection(polys)
ax[1,0].set_aspect('equal')
ax[1,0].set_xlim([xmin,xmax])
ax[1,0].set_ylim([ymin,ymax])
ax[1,0].axis('off')
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
ax[2,0].add_collection(polys)
ax[2,0].set_aspect('equal')
ax[2,0].set_xlim([xmin,xmax])
ax[2,0].set_ylim([ymin,ymax])
ax[2,0].axis('off')
# ======================================================================
xplot = np.zeros(N,dtype=bool)
xplot[0] = True
xplot[Ns-1] = True
xplot[(Ns-1)*Ns//2-1] = True
xplot[N-1] = True
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
ax[0,1].add_collection(polys)
ax[0,1].set_aspect('equal')
ax[0,1].set_xlim([xmin,xmax])
ax[0,1].set_ylim([ymin,ymax])
ax[0,1].axis('off')
xfil = Sf@xplot
for e in range(N):
    splot[sym[e,:]] = xfil[e]
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
polys.set_clim(0.0,1.0)
ax[1,1].add_collection(polys)
ax[1,1].set_aspect('equal')
ax[1,1].set_xlim([xmin,xmax])
ax[1,1].set_ylim([ymin,ymax])
ax[1,1].axis('off')
polys = clct.PolyCollection(coor[inci],cmap='cividis',edgecolor=(0,0,0,0))
polys.set_array(splot)
ax[2,1].add_collection(polys)
ax[2,1].set_aspect('equal')
ax[2,1].set_xlim([xmin,xmax])
ax[2,1].set_ylim([ymin,ymax])
ax[2,1].axis('off')
fig.set_size_inches(7,9)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
print('======================================================================')

#%% Morphology Filter
print('[Morphology Filter]')
plt.figure(num=3).clear()
fig,ax = plt.subplots(nrows=3,ncols=2,num=3)
# ======================================================================
for e in range(N):
    splot[sym[e,:]] = x4[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[0,0].add_collection(polys)
ax[0,0].set_aspect('equal')
ax[0,0].set_xlim([xmin,xmax])
ax[0,0].set_ylim([ymin,ymax])
ax[0,0].axis('off')
xplot = x4.copy()
xplot[Mf[~xplot,:].indices] = False
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[1,0].add_collection(polys)
ax[1,0].set_aspect('equal')
ax[1,0].set_xlim([xmin,xmax])
ax[1,0].set_ylim([ymin,ymax])
ax[1,0].axis('off')
xplot[Mf[xplot,:].indices] = True
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[2,0].add_collection(polys)
ax[2,0].set_aspect('equal')
ax[2,0].set_xlim([xmin,xmax])
ax[2,0].set_ylim([ymin,ymax])
ax[2,0].axis('off')
# ======================================================================
for e in range(N):
    splot[sym[e,:]] = x4[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[0,1].add_collection(polys)
ax[0,1].set_aspect('equal')
ax[0,1].set_xlim([xmin,xmax])
ax[0,1].set_ylim([ymin,ymax])
ax[0,1].axis('off')
xplot = x4.copy()
xplot[Mf[xplot,:].indices] = True
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[1,1].add_collection(polys)
ax[1,1].set_aspect('equal')
ax[1,1].set_xlim([xmin,xmax])
ax[1,1].set_ylim([ymin,ymax])
ax[1,1].axis('off')
xplot[Mf[~xplot,:].indices] = False
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[2,1].add_collection(polys)
ax[2,1].set_aspect('equal')
ax[2,1].set_xlim([xmin,xmax])
ax[2,1].set_ylim([ymin,ymax])
ax[2,1].axis('off')
fig.set_size_inches(7,9)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
print('======================================================================')

#%% Islands Removal
print('[Islands Removal]')
plt.figure(num=4).clear()
fig,ax = plt.subplots(nrows=3,ncols=3,num=4)
# ======================================================================
for e in range(N):
    splot[sym[e,:]] = x3[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[0,0].add_collection(polys)
ax[0,0].set_aspect('equal')
ax[0,0].set_xlim([xmin,xmax])
ax[0,0].set_ylim([ymin,ymax])
ax[0,0].axis('off')
y = x3.copy()
continent = np.zeros(N,dtype=bool)
for e in (list(range(0,Ns))+list(range(Ns,Nt,Ns))):
    if y[e] and (not continent[e]):
        continent = np.zeros(N,dtype=bool)    
        visit(e,y,continent,neighbors)
        continent_vol = sum(continent)/N
        break
islands = (y!=continent)
for e in range(N):
    splot[sym[e,:]] = continent[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[1,0].add_collection(polys)
ax[1,0].set_aspect('equal')
ax[1,0].set_xlim([xmin,xmax])
ax[1,0].set_ylim([ymin,ymax])
ax[1,0].axis('off')
for e in range(N):
    splot[sym[e,:]] = islands[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[2,0].add_collection(polys)
ax[2,0].set_aspect('equal')
ax[2,0].set_xlim([xmin,xmax])
ax[2,0].set_ylim([ymin,ymax])
ax[2,0].axis('off')
# ======================================================================
for e in range(N):
    splot[sym[e,:]] = x4[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[0,1].add_collection(polys)
ax[0,1].set_aspect('equal')
ax[0,1].set_xlim([xmin,xmax])
ax[0,1].set_ylim([ymin,ymax])
ax[0,1].axis('off')
y = x4.copy()
continent = np.zeros(N,dtype=bool)
for e in (list(range(0,Ns))+list(range(Ns,Nt,Ns))):
    if y[e] and (not continent[e]):
        continent = np.zeros(N,dtype=bool)    
        visit(e,y,continent,neighbors)
        continent_vol = sum(continent)/N
        break
islands = (y!=continent)
for e in range(N):
    splot[sym[e,:]] = continent[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[1,1].add_collection(polys)
ax[1,1].set_aspect('equal')
ax[1,1].set_xlim([xmin,xmax])
ax[1,1].set_ylim([ymin,ymax])
ax[1,1].axis('off')
for e in range(N):
    splot[sym[e,:]] = islands[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[2,1].add_collection(polys)
ax[2,1].set_aspect('equal')
ax[2,1].set_xlim([xmin,xmax])
ax[2,1].set_ylim([ymin,ymax])
ax[2,1].axis('off')
# ======================================================================
xplot = np.zeros(N,dtype=bool)
xplot[0:Ns] = True
xplot[Ns-1::Ns] = True
xplot[(Ns-2)*Ns//2:(Ns-2)*Ns//2+Ns//2] = True
xplot[(Ns-1)*Ns+1:(Ns-1)*Ns+Ns//2] = True
for e in range(N):
    splot[sym[e,:]] = xplot[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[0,2].add_collection(polys)
ax[0,2].set_aspect('equal')
ax[0,2].set_xlim([xmin,xmax])
ax[0,2].set_ylim([ymin,ymax])
ax[0,2].axis('off')
y = xplot.copy()
continent = np.zeros(N,dtype=bool)
for e in (list(range(0,Ns))+list(range(Ns,Nt,Ns))):
    if y[e] and (not continent[e]):
        continent = np.zeros(N,dtype=bool)    
        visit(e,y,continent,neighbors)
        continent_vol = sum(continent)/N
        break
islands = (y!=continent)
for e in range(N):
    splot[sym[e,:]] = continent[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[1,2].add_collection(polys)
ax[1,2].set_aspect('equal')
ax[1,2].set_xlim([xmin,xmax])
ax[1,2].set_ylim([ymin,ymax])
ax[1,2].axis('off')
for e in range(N):
    splot[sym[e,:]] = islands[e]
polys = clct.PolyCollection(coor[inci],cmap='gray_r',edgecolor=(0,0,0,0))
polys.set_array(splot+1.0)
polys.set_clim(0.0,2.0)
ax[2,2].add_collection(polys)
ax[2,2].set_aspect('equal')
ax[2,2].set_xlim([xmin,xmax])
ax[2,2].set_ylim([ymin,ymax])
ax[2,2].axis('off')
fig.set_size_inches(9,8)
plt.subplots_adjust(wspace=0.1, hspace=0.1)
print('======================================================================')
print('done!')